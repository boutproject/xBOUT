from pathlib import Path
from warnings import warn

import xarray as xr
import numpy as np

from .utils import _set_attrs_on_all_vars, _check_filetype, _separate_metadata


def open_grid(gridfilepath='./grid.nc', grid_type=None, ds=None, quiet=False):
    """
    Opens a BOUT++ grid file.

    Opens a BOUT++ grid file (as generated by Hypnotoad etc.). Then sets
    coordinates depending on what's in the file, and moves grid data to the
    attributes dict.

    Parameters
    ----------
    gridfilepath : str, optional
    grid_type : str, optional


        If not specified then will attempt to read it from the file attrs.
        If still not found then a warning will be thrown, which can be
        suppressed by passing `quiet`=True.
    ds : xarray.Dataset, optional
        BOUT dataset to merge grid information with.
        Leave unspecified if you just want to open the grid file alone.

    Returns
    -------
    ds : xarray.Dataset

    """

    gridfilepath = Path(gridfilepath)
    grid = xr.open_dataset(gridfilepath, engine=_check_filetype(gridfilepath))

    # TODO find out what 'yup_xsplit' etc are in the doublenull storm file John gave me
    # For now drop any variables with extra dimensions
    variables = list(grid.variables)
    vars_to_drop = [var for var in variables
                    if not all(dim in ['t', 'x', 'y', 'z']
                               for dim in grid[var].dims)]
    if vars_to_drop:
        warn("Will drop variables {} because they had unrecognised dimensions"
             .format(vars_to_drop))
    grid = grid.drop(vars_to_drop)

    # Merge into one dataset, with scalar vars in attrs
    grid, grid_metadata = _separate_metadata(grid)
    if ds is None:
        ds = grid
    else:
        ds = xr.merge(ds, grid)
    ds = _set_attrs_on_all_vars(ds, 'grid', grid_metadata)

    ds = _add_grid_coords(ds, grid_type, quiet)

    return ds


def _add_grid_coords(ds, grid_type, quiet=False):
        
    if grid_type is None:
        if grid_type in ds.attrs:
            grid_type = ds.attrs.get('grid_type')

    # TODO should this be refactored somewhere else to handle slabs with no grid file?
    # Define possible coordinate systems
    if grid_type == 'orthogonal':
        # Change names of dimensions to Orthogonal Toroidal ones
        ds = ds.rename(y='theta', inplace=True)

        # Add 1D Orthogonal Toroidal coordinates
        ny = ds.dims['theta']
        theta = xr.DataArray(np.linspace(start=0, stop=2 * np.pi, num=ny),
                             dims='theta')
        ds = ds.assign_coords(theta=theta)

        # TODO make this coordinate 1D in simplified cases?
        ds = ds.rename(psixy='psi', inplace=True)
        ds = ds.set_coords('psi')
        ds['psi'].attrs['units'] = 'Wb'

        # If full data (not just grid file) then toroidal dim will be present
        if 'z' in ds.dims:
            ds = ds.rename(z='phi', inplace=True)
            nz = ds.dims['phi']
            phi = xr.DataArray(np.linspace(start=0, stop=2 * np.pi, num=nz),
                               dims='phi')
            ds = ds.assign_coords(phi=phi)

        # Add 2D Cylindrical coordinates
        ds = ds.rename(Rxy='R', Zxy='Z', inplace=True)
        ds = ds.set_coords(['R', 'Z'])

    elif grid_type is None:
        # TODO Some definition of slabs?
        if not quiet:
            warn("No grid_type found, no coordinates will be added")

    else:
        raise ValueError("Unrecognised value of grid_type: {}"
                         .format(grid_type))

    # TODO special case for s-alpha?
    # Add radial coordinate
    #r = ds['hthe']
    #r.attrs['units'] = 'm'
    #ds = ds.assign_coords(r=r)

    return ds
